https://www.youtube.com/watch?v=YS4e4q9oBaU

⭐️ Course Contents ⭐️
⌨️ (0:00:00) Introduction
⌨️ (0:16:57) Setting Up a Development Environment
⌨️ (0:35:48) Variables
⌨️ (0:57:05) Primitives
⌨️ (1:26:29) Constants
⌨️ (1:47:53) Arrays and Slices
⌨️ (2:17:20) Maps and Structs
⌨️ (2:48:00) If and Switch Statements
⌨️ (3:21:17) Looping
⌨️ (3:41:34) Defer, Panic, and Recover
⌨️ (4:03:57) Pointers
⌨️ (4:21:30) Functions
⌨️ (4:57:59) Interfaces
⌨️ (5:33:57) Goroutines
⌨️ (6:05:10) Channels


Introduction
------------

Go was created by Google to address certain limitations of some of the main languages that they already use.

    Python: Easy to use but interpreted and slow.

    Java: Fast but an increasingly complicated type system.

    C/C++: Complex type system and slow compile time. Compilers are made to optimize a minimum amount of RAM.

All three of the above languages were created when multithreaded applications were rare. Concurrency patterns
in the above languages were later patched in.

What does go offer?

    Strong and statically typed just like Java/C++.

        Strong typing means that variable types cannot change over time.

        Static typing means that all the variables have to be defined at compile time.

        There are ways around the type system but 99% of the time Go is strong and statically typed.

        Unlike the above languages go has type inference so it does not need to be as verbose.

    Simplicity as a feature. A lot of the features we might be used to in other languages do not exist
    in Go.

        Go favors simplicity over complexity and this inevitably leads to features being left out.

    Fast compile times. Write -> Build -> Test process is fast and we can get feedback as quickly as possible.

    Garbage collection. We do not have to manage memory with go. We can manage our own memory but the Go runtime
    will handle this for us by default.

        Recent versions of Go have improved the performance of the garbage collector further.

    Built in concurrency. No external packages required.

    Go compiles down to a standalone binary. Everything needed is bundled into a single binary. The runtime, 
    libraries etc are all included. Version management at runtime is easy.

Some useful resources on the Go website...

    A playground: https://go.dev/play/

    A guide to structuring and best practices: https://go.dev/doc/effective_go

    Standard Library documentation: https://pkg.go.dev/std

        Not much for GUI applications at this point. Go is mostly focused on CLI, servers and web applications.

The basic format for a simple Go application is as follows...

    package main

    import "fmt"

    func main() {
        fmt.Println("Hello, 世界")
    }

Every application is structured into packages. We need to declare what package each file is a part of using the
'package' statement. The main package is the entry point to any Go application.

We import libraries using the 'import' statement. The "fmt" package allows us to format strings.


Go Installation
---------------

We can either install Go from the package manager or the binary from the website.

Go has an ENV variable called the GOPATH that sets the root directory where all of our projects are. By default
on Linux distros this is in the home/go directory.

    As we download packages that we need they will be installed in the GOPATH

We can install the Go extension in VSCode and then follow the prompts for any other go packages that it will
need for linting etc.

Once we have a simple go app we can run it as follows from a VSCode terminal...

    go run ./src/github.com/isoment/firstapp/Main.go

Another way to run a Go application is to use the build command...

    The project root must have a go.mod file...
        
        go mod init github.com/isoment/firstapp

    Then we can run...

        From the main directory...

            go build ./src/github.com/isoment/firstapp

        We can specify where the binary is outputted...

            go build -o ../path/to/binary

We can also use 'go install' this will compile a binary and install it in the GOPATH bin directory. In this case...
~/go/bin


Variables
---------

We can declare variables in Go a few different ways...

    var i int
    i = 45

    var i int = 45

    i := 45

All of the above are doing the same thing. We do not need to declare the type when using the shorthand method since
Go will use type inference.

We can print out the variable value and its type using the fmt.Printf() function.

When using the := syntax there is no way to specify the specific type. This can be useful when working with numbers.
Ie we have i := 45 but actually want the type to be a float.

    This syntax only works within functions and not at the package level. We need to use the full syntax to declare
    variables at the package level.

We can use the var block syntax to declare groups of variables at the same time...

    var (
        test string = "test"
        free string = "free"
    )

    This works at the package and function scope.

We cannot redeclare variables but we can declare a variable at the package scope and then redeclare it 
at the function scope...

    var i int = 27

    func main() {
        fmt.Println(i)
        var i int = 42
        fmt.Println(i)
    }

        The first print will be 27 and the second will be 42. The function scope takes precedence if a variable
        is re-declared. This is known as shadowing.

Variables in Go always need to be used in the function (local) scope. In the package scope they can be declared
and not used.

Variables in go can be lowercase or uppercase. A lower case variable declared in the package scope is only visible
from within the package. 'I' will be accessible outside of the package. 'j' will not be accessible.

    var I int = 27
    var j int = 4

    func main() {
    }

There are really only 3 scopes in Go...

    Package scope uppercase is accessible outside the package.

    Package scope lowercase is accessible within the package.

    Block scope variables are only visible from within the block.

Go has some variable naming conventions...

    In counters, loops etc it is common to have single letter variable names since the lifespan of these variables is
    small.

    If a variable is used many places throughout a longer function we want to name it something more meaningful.
    Either camel or pascal case.

    If the variable is declared at the package scope we need to be verbose in the naming.

    Acronyms should be all uppercase...

        var theURL string = "http://test"

Variables can be converted from one type to another...

    float32(i)
    int(i)
    string(i)

Go does not do implicit type conversions, ie a floating point cannot be assigned to an int.

We need to be careful when doing this because information can be lost or the results can be unexpected if we
don't know how Go works.

    A good example is converting an int to a string...

        i := 42
        j = string(i)

    The above will result in * because Go will look for the unicode value of 42 which is an asterisk. In Go
    strings are just alias for sequences of bytes. In Go, strings are made up of a sequence of Unicode code points, 
    which are typically represented using UTF-8 encoding. UTF-8 is a variable-length encoding, which means that 
    each Unicode code point can be represented using one to four bytes.

        Under the hood a string is actually a struct that contains a pointer to a block of memory that holds the
        bytes making up the string as well as an int representing the length of the string in bytes.

    The "strconv" package has a lot of useful functionality for string conversions with other data types.