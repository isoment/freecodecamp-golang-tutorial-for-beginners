https://www.youtube.com/watch?v=YS4e4q9oBaU

⭐️ Course Contents ⭐️
⌨️ (0:00:00) Introduction
⌨️ (0:16:57) Setting Up a Development Environment
⌨️ (0:35:48) Variables
⌨️ (0:57:05) Primitives
⌨️ (1:26:29) Constants
⌨️ (1:47:53) Arrays and Slices
⌨️ (2:17:20) Maps and Structs
⌨️ (2:48:00) If and Switch Statements
⌨️ (3:21:17) Looping
⌨️ (3:41:34) Defer, Panic, and Recover
⌨️ (4:03:57) Pointers
⌨️ (4:21:30) Functions
⌨️ (4:57:59) Interfaces
⌨️ (5:33:57) Goroutines
⌨️ (6:05:10) Channels


Introduction
------------

Go was created by Google to address certain limitations of some of the main languages that they already use.

    Python: Easy to use but interpreted and slow.

    Java: Fast but an increasingly complicated type system.

    C/C++: Complex type system and slow compile time. Compilers are made to optimize a minimum amount of RAM.

All three of the above languages were created when multithreaded applications were rare. Concurrency patterns
in the above languages were later patched in.

What does go offer?

    Strong and statically typed just like Java/C++.

        Strong typing means that variable types cannot change over time.

        Static typing means that all the variables have to be defined at compile time.

        There are ways around the type system but 99% of the time Go is strong and statically typed.

        Unlike the above languages go has type inference so it does not need to be as verbose.

    Simplicity as a feature. A lot of the features we might be used to in other languages do not exist
    in Go.

        Go favors simplicity over complexity and this inevitably leads to features being left out.

    Fast compile times. Write -> Build -> Test process is fast and we can get feedback as quickly as possible.

    Garbage collection. We do not have to manage memory with go. We can manage our own memory but the Go runtime
    will handle this for us by default.

        Recent versions of Go have improved the performance of the garbage collector further.

    Built in concurrency. No external packages required.

    Go compiles down to a standalone binary. Everything needed is bundled into a single binary. The runtime, 
    libraries etc are all included. Version management at runtime is easy.

Some useful resources on the Go website...

    A playground: https://go.dev/play/

    A guide to structuring and best practices: https://go.dev/doc/effective_go

    Standard Library documentation: https://pkg.go.dev/std

        Not much for GUI applications at this point. Go is mostly focused on CLI, servers and web applications.

The basic format for a simple Go application is as follows...

    package main

    import "fmt"

    func main() {
        fmt.Println("Hello, 世界")
    }

Every application is structured into packages. We need to declare what package each file is a part of using the
'package' statement. The main package is the entry point to any Go application.

We import libraries using the 'import' statement. The "fmt" package allows us to format strings.


Go Installation
---------------

We can either install Go from the package manager or the binary from the website.

Go has an ENV variable called the GOPATH that sets the root directory where all of our projects are. By default
on Linux distros this is in the home/go directory.

    As we download packages that we need they will be installed in the GOPATH

We can install the Go extension in VSCode and then follow the prompts for any other go packages that it will
need for linting etc.

Once we have a simple go app we can run it as follows from a VSCode terminal...

    go run ./src/github.com/isoment/firstapp/Main.go

Another way to run a Go application is to use the build command...

    The project root must have a go.mod file...
        
        go mod init github.com/isoment/firstapp

    Then we can run...

        From the main directory...

            go build ./src/github.com/isoment/firstapp

        We can specify where the binary is outputted...

            go build -o ../path/to/binary

We can also use 'go install' this will compile a binary and install it in the GOPATH bin directory. In this case...
~/go/bin


Variables
---------

We can declare variables in Go a few different ways...

    var i int
    i = 45

    var i int = 45

    i := 45

All of the above are doing the same thing. We do not need to declare the type when using the shorthand method since
Go will use type inference.

We can print out the variable value and its type using the fmt.Printf() function.

When using the := syntax there is no way to specify the specific type. This can be useful when working with numbers.
Ie we have i := 45 but actually want the type to be a float.

    This syntax only works within functions and not at the package level. We need to use the full syntax to declare
    variables at the package level.

We can use the var block syntax to declare groups of variables at the same time...

    var (
        test string = "test"
        free string = "free"
    )

    This works at the package and function scope.

We cannot redeclare variables but we can declare a variable at the package scope and then redeclare it 
at the function scope...

    var i int = 27

    func main() {
        fmt.Println(i)
        var i int = 42
        fmt.Println(i)
    }

        The first print will be 27 and the second will be 42. The function scope takes precedence if a variable
        is re-declared. This is known as shadowing.

Variables in Go always need to be used in the function (local) scope. In the package scope they can be declared
and not used.

Variables in go can be lowercase or uppercase. A lower case variable declared in the package scope is only visible
from within the package. 'I' will be accessible outside of the package. 'j' will not be accessible.

    var I int = 27
    var j int = 4

    func main() {
    }

There are really only 3 scopes in Go...

    Package scope uppercase is accessible outside the package.

    Package scope lowercase is accessible within the package.

    Block scope variables are only visible from within the block.

Go has some variable naming conventions...

    In counters, loops etc it is common to have single letter variable names since the lifespan of these variables is
    small.

    If a variable is used many places throughout a longer function we want to name it something more meaningful.
    Either camel or pascal case.

    If the variable is declared at the package scope we need to be verbose in the naming.

    Acronyms should be all uppercase...

        var theURL string = "http://test"

Variables can be converted from one type to another...

    float32(i)
    int(i)
    string(i)

Go does not do implicit type conversions, ie a floating point cannot be assigned to an int.

We need to be careful when doing this because information can be lost or the results can be unexpected if we
don't know how Go works.

    A good example is converting an int to a string...

        i := 42
        j = string(i)

    The above will result in * because Go will look for the unicode value of 42 which is an asterisk. In Go
    strings are just alias for sequences of bytes. In Go, strings are made up of a sequence of Unicode code points, 
    which are typically represented using UTF-8 encoding. UTF-8 is a variable-length encoding, which means that 
    each Unicode code point can be represented using one to four bytes.

        Under the hood a string is actually a struct that contains a pointer to a block of memory that holds the
        bytes making up the string as well as an int representing the length of the string in bytes.

    The "strconv" package has a lot of useful functionality for string conversions with other data types.


Primitives
----------

Go has three groups of primitive types, Boolean, Numeric and Text types.

Booleans are useful as state flags and for logical tests.

    When declaring a boolean and not initializing it the value is 0 and 0 evaluates to false. This is true of
    all primitives in Go. When we declare them but do not initialize them they have a default 0 value.

        var n bool, n will be equal to false

There are many different types of integers. The first type are the signed integers and there are many different
types for these.

    The int type is a signed integer of unspecified size. The size is unspecified since it depends on the
    system environment. It is at least 32bit but can be 64 or 128 depending on the system. This is the default
    integer type.

    Signed integer ranges...

        int8: -128, 127
        int16: -32768, 32767
        // A little over 2 billion
        int32: -2147483648, 2147483647
        // About 9.223 Quintillion
        int64: -9223372036854775808, 9223372036854775807

    Unsigned integers

        uint8: 0, 255
        uint16: 0, 65535
        uint32: 0, 4294967295

    There is also the 'byte' type which is an alias for uint8 and 'rune' which is an alias for int32.

Go has the standard numeric operators...

	fmt.Println(b + c)
	fmt.Println(b - c)
	fmt.Println(b * c)
	fmt.Println(b / c)
	fmt.Println(b % c)

For the division operator if we are dividing int and float the result is always an int. We cannot perform operations
on different types. Ie we cannot add a int8 to a int32. We have to do type conversion first.

Go has bit operators as well...

    fmt.Println(b & c) And
	fmt.Println(b | c) Or
	fmt.Println(b ^ c) Exclusive Or (XOR)
	fmt.Println(b &^ c) And not

    See the code for explanations

Go has bitshift operators...

    a := 8
    a << 3 Will shift a left 3 places
    a >> 3 Will shift a right 3 places

There are different ways to define floating point numbers in Go...

    var n float64 = 3.14
    n := 3.14
    n = 13.7e72
    n = 2.1E14

    We cannot do operations between float32 and float64. So if we are working with very large numbers always use 
    float64.

    Scientific notation can be declared with a 'E' or 'e'

        2.1e14 = 2.4 * 10^14
        2.1E14 = 2.4 * 10^14

    Floats have the following operators, there is no % operator and no bitwise or shifting operators!

        fmt.Println(b + c)
        fmt.Println(b - c)
        fmt.Println(b * c)
        fmt.Println(b / c)

Go has a complex type for numbers. There is a complex64 and complex128 type.

    A complex number is a number that can be expressed in the form a + bi, where a and b are real numbers and i is the 
    imaginary unit, which is defined as the square root of -1. In this expression, a is called the real part of the 
    complex number, and b is called the imaginary part.

    When working with complex numbers we may want to pull out the real or imaginary patterns

        The real() function will pull out the real part and the imag() will pull out the imaginary part.

	    var g complex64 = 1 + 2i
        fmt.Printf("%v, %T\n", real(a), real(a)) // 1, float32
        fmt.Printf("%v, %T\n", imag(a), imag(a)) // 2, float32

        We can create a complex number using complex()

            var g complex128 = complex(5, 12);
            // (5+12i), complex128

    We can use the + - * and / operators on complex numbers. + and - work just how we would expect. But remember from
    math classes how we use the distributive property of multiplication...

        z1 := complex(2, 3) // 2 + 3i
        z2 := complex(4, 5) // 4 + 5i
        z1 * z2
        = (2 + 3i) * (4 + 5i)          // Distributive property of multiplication
        = 2 * 4 + 2 * 5i + 3i * 4 + 3i * 5i
        = 8 + 10i + 12i + 15i^2        // Simplify the products of the imaginary unit i
        = 8 + 22i - 15                 // Substitute i^2 with -1
        = -7 + 22i

Text in go falls into two basic categories...

    Strings in Go are composed of any UTF-8 characters. This is powerful but means strings cannot encode every type
    of character available.

        Strings can be treated like an array as a collection of letters...

            s := "this is string"
            s[2] // returns the value 105 of uint8 type

        Strings in Go are just aliases for bytes.

        Strings are generally immutable. The individual chars cannot be changed. We can use the + operator to
        concatenate strings.

        s := "this is "
        s2 := "a string"
        s + s2

        Strings can be converted to collections or slices of bytes. Slices are like dynamic arrays. The array type
        in go is static and therefor of a fixed length.

            A lot of functions in Go work with byte slices. This makes them more flexible than hard coded strings.

    A Rune type represents any UTF-32 character whereas a Sting type represents any UTF-8 character.

        UTF-8 is a variable length encoding system that can represent any Unicode code point (character) using 
        one to four 8-bit bytes. The byte type in Go is a uint8. The byte type is an alias of uint8.

        UTF-32 assigns a 32-bit value to every Unicode code point. Every code point is represent by a 32-bit
        value as opposed to one to four 8bit bytes as in UTF-8

        Runes are declared using single quotes...

            rune := 'a'

        Runes are just a type alias for int32

        If we have a data string that is encoded in UTF-32 there are special functions Go has for returning
        the values out. For example ReadRune()

            https://pkg.go.dev/strings#Reader.ReadRune


Constants
---------

Constants are values that are assignable at compile time which we cannot change. We cannot set a constant to
something that has to be determined at runtime, the following will not work...

	const myConst float64 = math.Sin(1.54)

Constants can be any of the primitive types but they cannot be collection types like arrays. Constants can be 
shadowed just like variables. It isn't recommended to declare a const in the package scope and then in the block
scope.

Performing actions on variables and constants is allowed if they are the same type. Ie adding a const and var of
type int is assignable to a new variable.

    Typed constants work like immutable variables and since we specify the type they can only interoperate with
    the same type.

    Untyped constants work like literals (ie the literal value) and can interoperate with similar types ie
    const test = 42 an be added to 15.6

Const type can be inferred just like variables. The compiler will replace all instances of the constant in our
code with the actual value.

Go has a write only variable, it can assigned a value but not read from...

    const (
        _     = iota // 0
        cat          // 1
        dog          // 2
        snake        // 3
    )

    The _ tells the compiler that we will never need to read from this value

We can use operators when working with const


Arrays and Slices
-----------------

Arrays and slices are both collections of data. Arrays are the foundation of slices. Go has built in functions
for both of these. Array elements are contiguous in memory and therefor accessing them is very quick. Arrays contain 
only one type. All elements must be of this type. We can have arrays of arrays or structs.

To declare an array...

    grades := [3]int{90, 100, 85}

        [3] is the number of elements in the array. We then declare the type 'int'. We can then use the {} to 
        initialize the values in the array.

    grades := [...]int{90, 100, 85}

        We don't need to specify the number of elements when passing in the data during initialization.

    We don't need to pass in values for the array right away, we can declare the array and then assign values...

        var students [3]string
        students[0] = 'Bill'
        students[1] = 'Sally'

The first element in an array has an index of 0. Since arrays are made up of contiguous blocks of memory Go has
a pointer to the first block of memory, ie the beginning of the array. The index tells Go how many elements to walk
forward. When specify index 0 Go does not need to move forward to the next element, when we specify 1 it 
moves forward one element etc.

In Go when we declare an array assign it to a variable and then assign that variable to another we are making
a new copy of the array and not pointing ot the original one in memory. This is where pointers will come in.

Arrays have a limited use case since they are of fixed size. Slices are much more useful and function more like
how arrays do in PHP and Javascript.