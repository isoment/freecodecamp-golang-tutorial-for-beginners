https://www.youtube.com/watch?v=YS4e4q9oBaU

⭐️ Course Contents ⭐️
⌨️ (0:00:00) Introduction
⌨️ (0:16:57) Setting Up a Development Environment
⌨️ (0:35:48) Variables
⌨️ (0:57:05) Primitives
⌨️ (1:26:29) Constants
⌨️ (1:47:53) Arrays and Slices
⌨️ (2:17:20) Maps and Structs
⌨️ (2:48:00) If and Switch Statements
⌨️ (3:21:17) Looping
⌨️ (3:41:34) Defer, Panic, and Recover
⌨️ (4:03:57) Pointers
⌨️ (4:21:30) Functions
⌨️ (4:57:59) Interfaces
⌨️ (5:33:57) Goroutines
⌨️ (6:05:10) Channels


Introduction
------------

Go was created by Google to address certain limitations of some of the main languages that they already use.

    Python: Easy to use but interpreted and slow.

    Java: Fast but an increasingly complicated type system.

    C/C++: Complex type system and slow compile time. Compilers are made to optimize a minimum amount of RAM.

All three of the above languages were created when multithreaded applications were rare. Concurrency patterns
in the above languages were later patched in.

What does go offer?

    Strong and statically typed just like Java/C++.

        Strong typing means that variable types cannot change over time.

        Static typing means that all the variables have to be defined at compile time.

        There are ways around the type system but 99% of the time Go is strong and statically typed.

        Unlike the above languages go has type inference so it does not need to be as verbose.

    Simplicity as a feature. A lot of the features we might be used to in other languages do not exist
    in Go.

        Go favors simplicity over complexity and this inevitably leads to features being left out.

    Fast compile times. Write -> Build -> Test process is fast and we can get feedback as quickly as possible.

    Garbage collection. We do not have to manage memory with go. We can manage our own memory but the Go runtime
    will handle this for us by default.

        Recent versions of Go have improved the performance of the garbage collector further.

    Built in concurrency. No external packages required.

    Go compiles down to a standalone binary. Everything needed is bundled into a single binary. The runtime, 
    libraries etc are all included. Version management at runtime is easy.

Some useful resources on the Go website...

    A playground: https://go.dev/play/

    A guide to structuring and best practices: https://go.dev/doc/effective_go

    Standard Library documentation: https://pkg.go.dev/std

        Not much for GUI applications at this point. Go is mostly focused on CLI, servers and web applications.

The basic format for a simple Go application is as follows...

    package main

    import "fmt"

    func main() {
        fmt.Println("Hello, 世界")
    }

Every application is structured into packages. We need to declare what package each file is a part of using the
'package' statement. The main package is the entry point to any Go application.

We import libraries using the 'import' statement. The "fmt" package allows us to format strings.


Go Installation
---------------

We can either install Go from the package manager or the binary from the website.

Go has an ENV variable called the GOPATH that sets the root directory where all of our projects are. By default
on Linux distros this is in the home/go directory.

    As we download packages that we need they will be installed in the GOPATH

We can install the Go extension in VSCode and then follow the prompts for any other go packages that it will
need for linting etc.

Once we have a simple go app we can run it as follows from a VSCode terminal...

    go run ./src/github.com/isoment/firstapp/Main.go

Another way to run a Go application is to use the build command...

    The project root must have a go.mod file...
        
        go mod init github.com/isoment/firstapp

    Then we can run...

        From the main directory...

            go build ./src/github.com/isoment/firstapp

        We can specify where the binary is outputted...

            go build -o ../path/to/binary

We can also use 'go install' this will compile a binary and install it in the GOPATH bin directory. In this case...
~/go/bin


Variables
---------

We can declare variables in Go a few different ways...

    var i int
    i = 45

    var i int = 45

    i := 45

All of the above are doing the same thing. We do not need to declare the type when using the shorthand method since
Go will use type inference.

We can print out the variable value and its type using the fmt.Printf() function.

When using the := syntax there is no way to specify the specific type. This can be useful when working with numbers.
Ie we have i := 45 but actually want the type to be a float.

    This syntax only works within functions and not at the package level. We need to use the full syntax to declare
    variables at the package level.

We can use the var block syntax to declare groups of variables at the same time...

    var (
        test string = "test"
        free string = "free"
    )

    This works at the package and function scope.

We cannot redeclare variables but we can declare a variable at the package scope and then redeclare it 
at the function scope...

    var i int = 27

    func main() {
        fmt.Println(i)
        var i int = 42
        fmt.Println(i)
    }

        The first print will be 27 and the second will be 42. The function scope takes precedence if a variable
        is re-declared. This is known as shadowing.

Variables in Go always need to be used in the function (local) scope. In the package scope they can be declared
and not used.

Variables in go can be lowercase or uppercase. A lower case variable declared in the package scope is only visible
from within the package. 'I' will be accessible outside of the package. 'j' will not be accessible.

    var I int = 27
    var j int = 4

    func main() {
    }

There are really only 3 scopes in Go...

    Package scope uppercase is accessible outside the package.

    Package scope lowercase is accessible within the package.

    Block scope variables are only visible from within the block.

Go has some variable naming conventions...

    In counters, loops etc it is common to have single letter variable names since the lifespan of these variables is
    small.

    If a variable is used many places throughout a longer function we want to name it something more meaningful.
    Either camel or pascal case.

    If the variable is declared at the package scope we need to be verbose in the naming.

    Acronyms should be all uppercase...

        var theURL string = "http://test"

Variables can be converted from one type to another...

    float32(i)
    int(i)
    string(i)

Go does not do implicit type conversions, ie a floating point cannot be assigned to an int.

We need to be careful when doing this because information can be lost or the results can be unexpected if we
don't know how Go works.

    A good example is converting an int to a string...

        i := 42
        j = string(i)

    The above will result in * because Go will look for the unicode value of 42 which is an asterisk. In Go
    strings are just alias for sequences of bytes. In Go, strings are made up of a sequence of Unicode code points, 
    which are typically represented using UTF-8 encoding. UTF-8 is a variable-length encoding, which means that 
    each Unicode code point can be represented using one to four bytes.

        Under the hood a string is actually a struct that contains a pointer to a block of memory that holds the
        bytes making up the string as well as an int representing the length of the string in bytes.

    The "strconv" package has a lot of useful functionality for string conversions with other data types.


Primitives
----------

Go has three groups of primitive types, Boolean, Numeric and Text types.

Booleans are useful as state flags and for logical tests.

    When declaring a boolean and not initializing it the value is 0 and 0 evaluates to false. This is true of
    all primitives in Go. When we declare them but do not initialize them they have a default 0 value.

        var n bool, n will be equal to false

There are many different types of integers. The first type are the signed integers and there are many different
types for these.

    The int type is a signed integer of unspecified size. The size is unspecified since it depends on the
    system environment. It is at least 32bit but can be 64 or 128 depending on the system. This is the default
    integer type. Even on 64bit systems the int type often takes up 4 bytes or 32bits by default in memory.

    Signed integer ranges...

        int8: -128, 127
        int16: -32768, 32767
        // A little over 2 billion
        int32: -2147483648, 2147483647
        // About 9.223 Quintillion
        int64: -9223372036854775808, 9223372036854775807

    Unsigned integers

        uint8: 0, 255
        uint16: 0, 65535
        uint32: 0, 4294967295

    There is also the 'byte' type which is an alias for uint8 and 'rune' which is an alias for int32.

Go has the standard numeric operators...

	fmt.Println(b + c)
	fmt.Println(b - c)
	fmt.Println(b * c)
	fmt.Println(b / c)
	fmt.Println(b % c)

For the division operator if we are dividing int and float the result is always an int. We cannot perform operations
on different types. Ie we cannot add a int8 to a int32. We have to do type conversion first.

Go has bit operators as well...

    fmt.Println(b & c) And
	fmt.Println(b | c) Or
	fmt.Println(b ^ c) Exclusive Or (XOR)
	fmt.Println(b &^ c) And not

    See the code for explanations

Go has bitshift operators...

    a := 8
    a << 3 Will shift a left 3 places
    a >> 3 Will shift a right 3 places

There are different ways to define floating point numbers in Go...

    var n float64 = 3.14
    n := 3.14
    n = 13.7e72
    n = 2.1E14

    We cannot do operations between float32 and float64. So if we are working with very large numbers always use 
    float64.

    Scientific notation can be declared with a 'E' or 'e'

        2.1e14 = 2.4 * 10^14
        2.1E14 = 2.4 * 10^14

    Floats have the following operators, there is no % operator and no bitwise or shifting operators!

        fmt.Println(b + c)
        fmt.Println(b - c)
        fmt.Println(b * c)
        fmt.Println(b / c)

Go has a complex type for numbers. There is a complex64 and complex128 type.

    A complex number is a number that can be expressed in the form a + bi, where a and b are real numbers and i is the 
    imaginary unit, which is defined as the square root of -1. In this expression, a is called the real part of the 
    complex number, and b is called the imaginary part.

    When working with complex numbers we may want to pull out the real or imaginary patterns

        The real() function will pull out the real part and the imag() will pull out the imaginary part.

	    var g complex64 = 1 + 2i
        fmt.Printf("%v, %T\n", real(a), real(a)) // 1, float32
        fmt.Printf("%v, %T\n", imag(a), imag(a)) // 2, float32

        We can create a complex number using complex()

            var g complex128 = complex(5, 12);
            // (5+12i), complex128

    We can use the + - * and / operators on complex numbers. + and - work just how we would expect. But remember from
    math classes how we use the distributive property of multiplication...

        z1 := complex(2, 3) // 2 + 3i
        z2 := complex(4, 5) // 4 + 5i
        z1 * z2
        = (2 + 3i) * (4 + 5i)          // Distributive property of multiplication
        = 2 * 4 + 2 * 5i + 3i * 4 + 3i * 5i
        = 8 + 10i + 12i + 15i^2        // Simplify the products of the imaginary unit i
        = 8 + 22i - 15                 // Substitute i^2 with -1
        = -7 + 22i

Text in go falls into two basic categories...

    Strings in Go are composed of any UTF-8 characters. This is powerful but means strings cannot encode every type
    of character available.

        Strings can be treated like an array as a collection of letters...

            s := "this is string"
            s[2] // returns the value 105 of uint8 type

        Strings in Go are just aliases for bytes.

        Strings are generally immutable. The individual chars cannot be changed. We can use the + operator to
        concatenate strings.

        s := "this is "
        s2 := "a string"
        s + s2

        Strings can be converted to collections or slices of bytes. Slices are like dynamic arrays. The array type
        in go is static and therefor of a fixed length.

            A lot of functions in Go work with byte slices. This makes them more flexible than hard coded strings.

    A Rune type represents any UTF-32 character whereas a Sting type represents any UTF-8 character.

        UTF-8 is a variable length encoding system that can represent any Unicode code point (character) using 
        one to four 8-bit bytes. The byte type in Go is a uint8. The byte type is an alias of uint8.

        UTF-32 assigns a 32-bit value to every Unicode code point. Every code point is represent by a 32-bit
        value as opposed to one to four 8bit bytes as in UTF-8

        Runes are declared using single quotes...

            rune := 'a'

        Runes are just a type alias for int32

        If we have a data string that is encoded in UTF-32 there are special functions Go has for returning
        the values out. For example ReadRune()

            https://pkg.go.dev/strings#Reader.ReadRune


Constants
---------

Constants are values that are assignable at compile time which we cannot change. We cannot set a constant to
something that has to be determined at runtime, the following will not work...

	const myConst float64 = math.Sin(1.54)

Constants can be any of the primitive types but they cannot be collection types like arrays. Constants can be 
shadowed just like variables. It isn't recommended to declare a const in the package scope and then in the block
scope.

Performing actions on variables and constants is allowed if they are the same type. Ie adding a const and var of
type int is assignable to a new variable.

    Typed constants work like immutable variables and since we specify the type they can only interoperate with
    the same type.

    Untyped constants work like literals (ie the literal value) and can interoperate with similar types ie
    const test = 42 an be added to 15.6

Const type can be inferred just like variables. The compiler will replace all instances of the constant in our
code with the actual value.

Go has a write only variable, it can assigned a value but not read from...

    const (
        _     = iota // 0
        cat          // 1
        dog          // 2
        snake        // 3
    )

    The _ tells the compiler that we will never need to read from this value

We can use operators when working with const


Arrays and Slices
-----------------

Arrays and slices are both collections of data. Arrays are the foundation of slices. Go has built in functions
for both of these. Array elements are contiguous in memory and therefor accessing them is very quick. Arrays contain 
only one type. All elements must be of this type. We can have arrays of arrays or structs.

To declare an array...

    grades := [3]int{90, 100, 85}

        [3] is the number of elements in the array. We then declare the type 'int'. We can then use the {} to 
        initialize the values in the array.

    grades := [...]int{90, 100, 85}

        We don't need to specify the number of elements when passing in the data during initialization.

    We don't need to pass in values for the array right away, we can declare the array and it will be filled with the deefault
    values for the type. We can then assign values...

        var students [3]string
        students[0] = 'Bill'
        students[1] = 'Sally'

The first element in an array has an index of 0. Since arrays are made up of contiguous blocks of memory Go has
a pointer to the first block of memory, ie the beginning of the array. The index tells Go how many elements to walk
forward. When specify index 0 Go does not need to move forward to the next element, when we specify 1 it 
moves forward one element etc.

In Go when we declare an array assign it to a variable and then assign that variable to another we are making
a new copy of the array and not pointing ot the original one in memory. This is where pointers will come in.

Arrays have a limited use case since they are of fixed size. Slices are much more useful and function more like
how arrays do in PHP and Javascript.

Slices have underlying arrays. But they do not have a fixed size. We can add and remove elements from them.

A slice can be declared and initialized with data as follows...

    a := []int{1, 2, 3}

Slices are reference types a slice is pointing to an array in memory, it can be a fragment of that array
or the whole thing. Unlike arrays they are not copied when referenced...

    a := []int{1, 2, 3}
    b := a

        b is referencing a directly in memory

There are other ways to create slices, these can all be used on arrays as well...

    a := []int{1, 2, 3, 4, 5, 6, 7}
    b := a[:]     // Create a slice of all the elements in a
    c := a[3:]    // Create a slice from the 4th element to the end
    d := a[:6]    // Slice the first 6 elements
    e := a[3:6]   // Slice the 4th, 5th and 6th elements

For the above syntax the first number is inclusive (included) and the second is exclusive (not included)

When we create slices they are using arrays under the hood. When we append elements to a slice, Go may need to 
allocate a new underlying array if the current array is not large enough to hold the new elements. In this case, 
Go will create a new array, copy the contents of the old array into the new array, and update the slice's 
pointer to point to the new array.

The append() function will add a new element to a slice...

    h := []int{}
	h = append(h, 1, 2, 3, 4)

The append() function is variadic. It accepts as many arguments as need be, each argument after the first
will be added to the array.


Maps
----

Maps in Go are collections of key value pairs. All of the keys have to be of one type and the values do as
well. Every key value pair in the map has to be of the defined types. To declare a map...

    townPopulations := map[string]int{
        "Faketown": 7434,
        "Fakeville": 420012,
        "Fakeburg": 472384,
        "Fakeglenn": 9182
    }

We can also use the make function to declare a map...

    townPopulations := make(map[string]int)

The return order of a map is not guaranteed. Maps are higher level abstractions of hash tables.

Keys can be anything that is testable for equality. Most data types can be used. Slices, maps and other functions
cannot be used as keys.

We can get values from the map by using a variable or a literal...

    townName := "Fakeburg"
    townPopulations["Fakeburg"]
    townPopulations[townName]

To delete a value from a map...

    delete(townPopulations, "Fakeburg")

If the key does not exist in that map a 0 is returned. This can be problematic if our map has any 0 values in it.
We can use a different syntax to check if the key is in the map...

    pop, ok := townPopulations["Missingtown"]

Maps like slices can be referenced in new variables and modified. When modifying the reference the original is
modified as well.


Structs
-------

Structs are mixed collections of data, similar to how objects contain data in OOP languages. They are powerful in
the sense that their structure can be completely customized and contain all different types of data.

Here is an example of defining a struct...

    type Animal struct {
        legs       int
        name       string
        attributes []string
    }

    func main() {
        dog := Animal{
            legs:       4,
            name:       "Rover",
            attributes: []string{"Furry", "Smelly", "Likes to drool"},
        }
        fmt.Println(dog)
    }

	fmt.Println(dog.attributes[0])

When creating a dog from the Animal struct we can omit the keys. This will still work as long as they are in
the correct order but this is not a good idea and can make things difficult to maintain.

Just like with naming variables any structs starting with a capital letter are visible outside. If the want
the field names to be available to the outside they also need to be capitalized.

    type Animal struct {
        Legs       int
        Name       string
        Attributes []string
    }

Struct names should be pascal case or camel case and not contain any underscores symbols etc.

We can declare anonymous structs...

    aDoctor:= struct{name string}{name: "Billford"}

These are not as commonly used as regular structs.

When creating a struct from another struct modifying the new one does not change the original. Unlike maps and slices
structs are independent data sets. Keep this in mind when passing them around since they do take up memory.

	anotherDoctor := aDoctor
	anotherDoctor.name = "Sally"

    If we do want to reference the original we can use the address of operator and set a pointer anotherDoctor is a
    pointer to aDoctor...

    	anotherDoctor := &aDoctor
	    anotherDoctor.name = "Sally"

Go doesn't have traditional OOP concepts like inheritance. It instead favors the use of composition thorugh embedding.
Embedding is generally not used for behavior, it is better to use interfaces. Embedding is useful for getting some
base behavior into a custom type.

When creating structs we can define a tag...

    type Request struct {
        Name string `required max:"100"`
        Origin string
    }

    Tags are enclosed in backticks and have space delimited key value pairs, we do not need to specify a value
    just a key is fine. To access this tag we can use reflection


If Statements
-------------

If statements in go do not have () but they do have curly braces. The curly braces are required there are no
single lin if statements in Go.

    if true {
        fmt.Println("Hello")
    }

If statements can have initializers. This is where we assign the value of an expression to a variable In
the if statement itself. The variable (a) is available in the block scope of the if statement but not
outside of it.

    if a := 2 > 1; a {
        fmt.Println("Hello")
    }

We can use operators that result in a boolean value for if statements. We can also use || and && and ! for not

    if a <= b || b > d {
        ...
    }

    if !a < b && c {
        ...
    }

We need to be careful with floating point number comparison just like in other languages. They are approximations
and can have results we don't expect if we are not careful.


Switch Statements
-----------------

Switch statements work just like in most other languages but have some unique features. Cases can have different
options.

	switch 1 {
	case 1, 8, 9:
		fmt.Println("one eight nine")
	case 2:
		fmt.Println("two")
	default:
		fmt.Println("default")

	}

We can also use initializers in case statements...

    switch i := 2 + 3; i {
	case 1, 8, 9:
		fmt.Println("one eight nine")
	case 2, 5:
		fmt.Println("two five")
	default:
		fmt.Println("default")

	}

In PHP and JS there is a break statement in switches. In Go the break statement is implied. When we do not want
a break we can use the fallthrough keyword. Using the fallthrough statement in a switch block means the next block is 
entered even if the expression doesn't match but this is only valid when there has already been a match. This
isn't used very often.


Looping
-------

Unlike many other languages go has only one type of loop, the for loop...

	for i := 0; i < 5; i++ {
		fmt.Println(i)
	}

The initializer in the for loop can be outside and scoped to the function, in the above i is scoped
to the loop block...

    i := 0
    for ; i < 5; i++ {
		fmt.Println(i)
    }

We can also omit the incrementor, the equivalent of a do while loop...

    i := 0
    for i < 5 {
		fmt.Println(i)
        i++
    }


Defer
-----

Control flows from the top to bottom of any function that we call. We can alter this using Defer

    func main() {
        fmt.Println("start")
        defer fmt.Println("middle")
        fmt.Println("end")
    }

The Println with defer is printed last. This is because defer adds the function call to a stack. They are then called
in a last in first out order.

    func main() {
        a := "start"
        defer fmt.Println(a)
        a = "end"
    }

    When we defer a function it will take any of its arguments at the time the defer is called.


Panic and Recover
-----------------

There are no exceptions in Go. A lot of cases that are considered exceptions in other languages are considered
normal in a Go application. Ie opening a file.

    We usually use errors to handle what would be considered exceptions in other languages.

Panics happen when a Go application cannot figure out what to do and therefor cannot continue. Go lets us
determine when the application should panic. Many Go functions return error values under certain circumstances and 
it is up to us how we want to deal with them.

Panics do not have to be fatal. They are if they get all the way up to the Go runtime since then the application
will be killed. Panics happen after defer statements are executed...

    func main() {
        fmt.Println("start")
        defer fmt.Println("DEFER")
        panic("DANGER DANGER DANGER DANGER")
        fmt.Println("end")
    }

    The order of execution...

        The main function is executed, and we see "start" printed.

        Then any deferred statements are executed.

        Then panics are handled.

        Then the return value is handled.

Deferred statements that close resources will still succeed even if the application panics.

Go has a built in method called recover() which allows us to restore the normal execution of a program 
and handle the error passed to panic. recover() catches panic errors and allows us to handle them instead
of having a panic go all the way up to a runtime and terminate the application.


Pointers
--------

Every variable that we declare is stored in memory in a location. Every memory location has an address,
we can see the address for a particular variable as follows...

    func main() {
        var a int = 10   
        fmt.Printf("Address of a variable: %x\n", &a  )
    }

Pointers are variables that have a value that is the memory address of another variable. They point to the
direct memory address where the information is located. We can use the address of operator '&' to specify
the pointer...

    var a int = 10
    var b *int = &a

Go does not allow pointer arithmetic. Pointer arithmetic offers a lot of performance benefit but adds
complexity. There is an unsafe Go package that offers operations that the Go runtime will not check for us.
If we really need to do pointer arithmetic we can with this package.

Example of pointer arithmetic...

	c := [3]int{1, 2, 3}
	d := &c[0]
	e := &c[1] - 4
	fmt.Printf("%v %p %p\n", c, d, e)

    The e variable is pointing to the memory location of the second element in the c array. each int in the
    array takes up 4 bytes in memory. By subtracting 4 from e we expect to be pointing to the c[0] memory location
    but Go will throw an error since this is not allowed.

Data types like slices make use of pointers. Slices are just projections of underlying arrays. The slice doesn't
contain the data itself but references to the data in the underlying array. When slices are shared in our
applications we will always be pointing at the same underlying array.

    Maps also have this behavior since they just have pointers to the underlying data.

    We need to always be aware of how slices and maps are being passed around and used since the data underlying
    data that they point to can be modified in unexpected ways. With primitives, arrays, structs this isn't an
    issue.


Functions
---------

Just like in other languages functions are bits of reusable code. The entry of every Go application is
the main() function that takes no parameters and returns no values.

Go has a feature not common in other languages, return types from functions can be pointers. This allows us
to return a function scoped variable as a pointer. We are returning the memory address of the value and not
the actual value itself.

	s := sum(1, 2, 3, 4)
	fmt.Println("The sum is", *s)

    func sum(values ...int) *int {
        fmt.Println(values)
        result := 0
        for _, v := range values {
            result += v
        }
        return &result
    }

Returning pointers in other languages can be problematic because once the function executes the value in memory
that the function creates is freed up and the pointer could be pointing to a location that was freed and there is
no way to know which value will be there. In Go when a pointer is returned it will make sure that the value
in memory is pushed onto the shared heap memory so when we use the pointer we can be sure that it is referencing
the correct value.

In Go functions can have named return values, the named value will be available within our function and is 
implicitly returned. This isn't used very frequently.

	s := sum(1, 2, 3, 4)
	fmt.Println("The sum is", s)

    func sum(values ...int) (result int) {
        fmt.Println(values)
        for _, v := range values {
            result += v
        }
        return
    }

Go functions can have multiple return values! See code example

Functions in go can be treated as types. They can be passed as parameters to functions, given as return values etc.

Go supports anonymous functions, these are not very useful except for maybe limiting variable scope.

	func() {
		fmt.Println("Hello Go!")
	}()

When working with functions as variables we need to make sure that they are defined before we execute them

	b := func() {
		fmt.Println("Hello Go!")
	}
	b()

Go also has methods. A method os just a function executing in a known context. A known context in Go is any type.
Structs are commonly used but we can add methods to any declared type.

    func main() {
        g := greeter{
            greeting: "Hello",
            name: "Go"
        }
        g.greet()
    }

    type greeter struct {
        greeting string
        name string
    }

    // This is where we provide the context that the method executes in. We can see in the main() function that
    // we can now call greet on the greeter struct. If we want to manipulate the original struct we can modify
    // the example to receive a pointer (g *greeter)
    func (g greeter) greet() {
        fmt.Println(g.greeting, g.name)
    }


Interfaces
----------

We have already seen how structs are used to define and store data. Interfaces define behavior. A sample interface...

    type Writer interface {
        Write([]byte) (int, error)
    }

    Anything that implements the interface above must accept a slice of bytes as an input and return an int and
    error.

Interfaces in many languages are explicitly implemented. The interface must be defined before it is implemented. In Go
interfaces are implicit, we don't need to create interfaces until we need them.

Single method interfaces are very common and should be named with the 'er suffix if at all possible.

Any type that can have a method associated with it can implement an interface.

    type Incrementor interface {
        Increment() int
    }

    type IntCounter int

    func (ic *IntCounter) Increment() int {
        *ic++
        return int(*ic)
    }

Interfaces can be embedded in other interfaces...

    type Writer interface {
        Write([]byte) (int, error)
    }

    type Closer interface {
        Close() error
    }

    type WriterCloser interface {
        Writer
        Closer
    }

Go allows us to convert interfaces just like we can convert other types. Below we are trying to convert the wc
variable to an io.Reader. In this case we cannot convert because io.Reader does not have a read method so we need
to account for this...

    var wc WriterCloser = NewBufferedWriterCloser()

    r, ok:= wc.(io.Reader)
    if ok {
        fmt.Println(r)
    } else {
        fmt.Println("Conversion failed")
    }

An interface can be empty, ie an object with no methods on it. Everything can be cast to this including primitives.
This is useful as an intermediate step, we receive a value and need to do some steps to determine what it is. Every
type in Go implements the empty interface!

    interface{}

    The empty interface is often used with a type switch.

There are some useful best practices when it comes to interfaces...

    It is better to use numerous small interfaces than few very large ones. Some of the interfaces in the
    standard library to take a look at...

        io.Writer
        io.Reader
        interface{}

    Don't export interfaces for types that will be consumed. Do export interfaces for types that you will be consuming. 
    If we don't need the interface for our own use don't export it instead export the concrete type. If we were to 
    create a library we can specify the interfaces we accept and the user can define them however they want.

        Export concrete types and accept interfaces whenever possible.

        Design functions and methods to receive interfaces whenever possible.

There a differences when implementing an interface with values vs pointers.

    The method set of value is all methods with value receiver. If we implement an interface with value types
    all the methods of the interface must have value receivers.

    The method set of of pointer is all methods regardless of receiver type, all of the value AND pointer receivers.
    This is more flexible but allows access to the underlying data through the pointer.


Goroutines
----------

Concurrency is the applications ability to work on multiple things. This does not mean they have to run in parallel.
It means that two or more tasks start, run and complete in overlapping time periods. Parallelism is when tasks run at 
the same time. Imagine the following...

    Concurrency can be illustrated by two lines of customers ordering from a single cashier. Each line will take
    turns ordering. Each line of customers are the programming instructions and the cashier is the CPU core. We only
    have one CPU core and it can only process one thing at a time despite there being multiple processes.

    Parallelism is when we have a cashier (CPU core) for each line. This is only possible with multiple cores.

Go used green threads for concurrency. A green thread is a thread that is scheduled by a runtime library or a virtual
machine as opposed to the operating system. They do no rely on the hosts native abilities. Modern Go uses the
operating system threads directly to implement goroutines.

    Operating system threads have an individual function callstack dedicated to whatever code is handed to that
    thread. These are large and take time to setup. Creating and destroying threads is expensive and we want to
    avoid it whenever possible. Thread pooling is a result of the expensive nature of this process.

    Go logical threads are abstractions of threads called goroutines. There is a scheduler in the Go runtime that
    maps goroutines onto the operating system threads for a period of time. The scheduler does all of this
    for us.

    Goroutines are managed by the Go runtime, which multiplexes many goroutines onto a smaller number of operating 
    system threads, using techniques such as work-stealing and preemption to efficiently schedule and 
    manage goroutines.

        The advantage of this is that goroutines can start with very small stack spaces, they can be reallocated
        very quickly. It is very cheap to create and destroy them unlike operating system threads. Tens of
        thousands of these can run at the same time.

A basic goroutine...

    func main() {
        go sayHello()
        time.Sleep(100 * time.Millisecond)
    }

    func sayHello() {
        fmt.Println("Hello")
    }

Go routines do not have to be named functions. The following is valid, also note that the closure has access to
variables in the outer scope. Even though the goroutine is running in a different execution stack the Go runtime
understands where to get the msg variable.

    var msg = "Hello"
    go func() {
        fmt.Println(msg)
    }()

The above code will result in a race condition. We should pass external data as an argument for use in the goroutine.

    var msg = "Hello"
    go func(msg string) {
        fmt.Println(msg)
    }()

When working with goroutines we often need to wait for an operation to finish so we can use the data for something
else. Go has WaitGroups which are designed to synchronize multiple goroutines together. Here we only have one
goroutine doing any work but the syntax for working with WaitGroups is clear.

    var wg = sync.WaitGroup{}

    func main() {
        var msg = "Hello"
        wg.Add(1)
        go func(msg string) {
            fmt.Println(msg)
            wg.Done()
        }(msg)
        msg = "Goodbye"
        wg.Wait()
    }

    A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of 
    goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait 
    can be used to block until all goroutines have finished.

Go has mutexes built in. A mutex is a way for us to protect shared resources from concurrent access by many
goroutines. A mutex is like a lock that can be used to ensure that only one goroutine has access to a shared
resource at a time.

    var mutex = &sync.Mutex{}
    var counter = 0

    func increment() {
        mutex.Lock()
        defer mutex.Unlock()
        counter++
    }

    The Lock() method is used to acquire the lock and the Unlock() method will release it. These are for
    locking and unlocking writing.

    In the above example we are using the mutex to protect the counter variable so only one goroutine has access to
    it at a time. This prevents data races and synchronization issues.

With a standard mutex only one thing can access the data at a time. With an RWMutex as many things as want to can read 
the data but only one thing can be writing it at a time. If anything is reading we cannot write to it at all.

	RLock() and RUnlock() lock and unlock reading.

The examples we have been using to illustrate concurrency are not useful. Concurrency is not something that should
be applied to everything and in fact applying it to unsuitable problems will often make performance worse.

Get and set the max CPUs that a Go program to use at once. By default Go will create however many threads the CPU 
provides. For example on a 4 core CPU each core has two threads so the default will be 8.

    func main() {
        runtime.GOMAXPROCS(100)
        fmt.Printf("Threads: %v\n", runtime.GOMAXPROCS(-1))
    }

    We can increase the value beyond this though it does not always improve performance. We are telling the Go
    runtime to create this amount of logical threads. We many only have 8 operating system threads, these are
    not the same as Linux threads and are limited to the threads on the CPU.

Some best practices for working with goroutines...

    Avoid creating goroutines in libraries, let the consumer control this.

    When creating a goroutine know how it will end, this will avoid subtle memory leaks. If we don't end it
    in some way it will go on indefinitely and drain resources.

    Check for race conditions at compile time. When compiling our program we can use the following. It is
    strongly recommended to run this...

        go run -race ...


Channels
--------

Most programming languages were designed under the assumption they would be used on a machine with a single 
processing core. Go was built later when multi-core processors were commonplace.

As we saw in the previous session goroutines are abstractions that make it easier to work concurrently but
there are some issues like race conditions and memory sharing problems.

    Go introduces a feature called Channels that can address the above issues.

Channels are used in the context of goroutines. They are used to synchronize data transmission between multiple
goroutines.

To create a channel we need to use the make() function. We have seen this function being used to create maps
and slices. With those types there were multiple ways to create them but with channels we need to use make().

When creating a channel it can only accept messages of a certain type, for example the following will only accept
int values.

    make(chan int)

A channel can be either buffered or unbuffered. A buffered channel can only contain a single item at a time.
When we send a value into an unbuffered channel will block the channel until another goroutine receives the
value.

    A buffered channel can hold a fixed number of items which is defined when the channel is created.
    To create a buffered channel...

        ch := make(chan int, 50)

        Buffered channels are designed for when either the sender or the receiver needs more time to process
        the information coming from the other side.

    The order of items in a channel is preserved.

Channels are by default bi-directional. We can create channels that are either send only or receive only.

    Send only...

        ch chan<- int

    Receive only...

        ch <-chan int

Go routines are commonly used for asynchronous operations. When using channels we can have multiple goroutines
sending data into a channel.

    One channel can be distributed among multiple goroutines. There can be multiple data generators sending data
    into the channel.

    In a situation where we are able to generate data very fast but need more time to process it we can have a
    single goroutine sending data through a channel to multiple goroutines.

We can close a channel using close(), we need to make sure that nothing is being sent into the channel
or else Go will panic.

    func main() {
        ch := make(chan int, 50)
        wg.Add(2)
        go func(ch <-chan int) {
            for i := range ch {
                fmt.Println(i)
            }
            wg.Done()
        }(ch)
        go func(ch chan<- int) {
            ch <- 42
            ch <- 52
            close(ch)
            wg.Done()
        }(ch)
        wg.Wait()
    }

The select statement is waiting for communication to occur on one of the channels. When a value is received from
logCh we will print the log, when a signal is sent from the doneCh the loop is broken.

    for {
        select {
        case entry := <-logCh:
            fmt.Printf("%v - [%v]%v\n", entry.time.Format("2006-01-02T15:04:05"), entry.severity, entry.message)
        case <-doneCh:
            break
        }
    }

A select statement chooses the first channel that is ready to communicate, i.e., the one that has a value ready 
to be received or the one that is ready to receive a value. If multiple channels are ready, then one of 
them is chosen randomly. The ordering of the case statements does not matter.

Select statements can be used in various scenarios where multiple channels are involved, such as waiting for 
data from multiple sources, coordinating multiple concurrent operations, and managing timeouts or cancellation of operations.